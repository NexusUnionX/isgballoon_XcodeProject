#import "ISgballoonTally.h"
#import "ISgballoonDamage.h"
#import "ISgballoonTrammel.h"
#import "ISgballoonObjectify.h"
#import "ISgballoonAnimize.h"
#import "ISgballoonEnsconce.h"
#import <YYModel/YYModel.h>
#import "ISgballoonProfessionalise.h"
#import "ISgballoonEnsconce.h"
#import "ISgballoonDamage.h"
#import "ISgballoonDomesticise.h"
#import "ISgballoonAllow.h"
#import "ISgballoonDeprave.h"
#import "ISgballoonExteriorise.h"
#import "ISgballoonExpand.h"
#import "ISgballoonTrammel.h"
#import "ISgballoonSubtilize.h"
static NSInteger closurePageConsort = 20; 
static NSInteger closurePageSuggest = 95; 
@interface ISgballoonAllow ()
@property (nonatomic, strong) NSMutableArray<NSString *> *referenceReferenceBrown; 
@property (nonatomic, strong) dispatch_queue_t referenceReferenceStareDown;         
@property (nonatomic, assign) BOOL referenceReferenceBeneficiate; 
@property (nonatomic, assign) ISGBALLOONClassifierDirectType referenceReferenceMold;
@property (nonatomic, assign) BOOL referenceReferencePaint;
@property (nonatomic, assign) BOOL referenceReferenceTweak;
@end
@implementation ISgballoonAllow
- (void)instanceMethodIsgballoonNitrify {
    @synchronized (self) {
        self.referenceReferencePaint = NO;
    }
}
- (void)instanceMethodIsgballoonCalmDown:(ISGBALLOONInditeBlock)completeInitParam {
    if (self.referenceReferenceBeneficiate || self.referenceReferenceBrown.count == 0) {
        if (completeInitParam) {
            completeInitParam(true);
        }
        return;
    }
    self.referenceReferenceBeneficiate = YES;
    NSArray<NSString *> *ephemeralStateEphemeralStateSee = [self.referenceReferenceBrown copy];
    dispatch_group_t ephemeralStateEphemeralStateSlide = dispatch_group_create();
    NSMutableArray<NSString *> *ephemeralStateEphemeralStateTravelBy = [NSMutableArray array];
    NSObject *ephemeralStateEphemeralStateEwelease = [[NSObject alloc] init]; 
    NSUInteger ephemeralStateEphemeralStateSki = closurePageSuggest;
    for (NSUInteger i = 0; i < ephemeralStateEphemeralStateSee.count; i += ephemeralStateEphemeralStateSki) {
        NSRange ephemeralStateEphemeralStateRelight = NSMakeRange(i, MIN(ephemeralStateEphemeralStateSki, ephemeralStateEphemeralStateSee.count - i));
        NSArray<NSString *> *ephemeralStateEphemeralStateWhistle = [ephemeralStateEphemeralStateSee subarrayWithRange:ephemeralStateEphemeralStateRelight];
        if (ephemeralStateEphemeralStateWhistle.count == 0) {
            continue;
        }
        dispatch_group_enter(ephemeralStateEphemeralStateSlide);
        [self instanceMethodIsgballoonSovietise:ephemeralStateEphemeralStateWhistle czbpReloadableUndertake:^(BOOL czbpCentralizedBringforth) {
            if (czbpCentralizedBringforth) {
                @synchronized(ephemeralStateEphemeralStateEwelease) {
                    [ephemeralStateEphemeralStateTravelBy addObjectsFromArray:ephemeralStateEphemeralStateWhistle];
                }
            }
            dispatch_group_leave(ephemeralStateEphemeralStateSlide);
        }];
    }
    dispatch_queue_t ephemeralStateEphemeralStateMoveAround = [self instanceMethodIsgballoonPrefigure];
    dispatch_group_notify(ephemeralStateEphemeralStateSlide, ephemeralStateEphemeralStateMoveAround, ^{
        if (ephemeralStateEphemeralStateTravelBy.count > 0) {
            [self.referenceReferenceBrown removeObjectsInArray:ephemeralStateEphemeralStateTravelBy];
        }
        self.referenceReferenceBeneficiate = NO;
        if (self.referenceReferenceBrown.count > 0) {
            if (self.referenceReferencePaint == false) {
                [self instanceMethodIsgballoonAllegorise];
            } else {
            }
            if (completeInitParam) {
                completeInitParam(true);
            }
        } else {
            if (completeInitParam) {
                completeInitParam(true);
            }
        }
    });
}
- (void)instanceMethodIsgballoonEngender:(NSString *)CZBPFlowTouchon czbpReloadableWoo:(NSDictionary *)CZBPFlowGoover {
    if (CZBPFlowTouchon == nil || [CZBPFlowTouchon length] == 0) {
#if DEBUG
        NSString *ephemeralStateEphemeralStateTrek = [NSString stringWithFormat:closurePageElectrify,self.referenceReferenceMold, CZBPFlowGoover];
#endif
        return;
    }
    [self instanceMethodIsgballoonInitiate:@[CZBPFlowTouchon]];
}
- (void)instanceMethodIsgballoonExtract {
    if (self.referenceReferenceBrown.count == 0) {
        return; 
    }
    NSString *ephemeralStateEphemeralStateArise = closurePageCheckOver;
    NSUserDefaults *ephemeralStateEphemeralStateTakeTheAir = [NSUserDefaults standardUserDefaults];
    [ephemeralStateEphemeralStateTakeTheAir setObject:self.referenceReferenceBrown forKey:ephemeralStateEphemeralStateArise];
    BOOL success = [ephemeralStateEphemeralStateTakeTheAir synchronize];
    if (success) {
    } else {
    }
}
-(NSMutableArray *)referenceReferenceBrown {
    if (_referenceReferenceBrown == nil) {
        _referenceReferenceBrown = [NSMutableArray array];
    }
    return _referenceReferenceBrown;
}
-(void)instanceMethodIsgballoonStreak:(UIBackgroundTaskIdentifier)ephemeralStateEphemeralStateGhost {
    [self instanceMethodIsgballoonExtract];
    if (ephemeralStateEphemeralStateGhost != UIBackgroundTaskInvalid) {
        [[UIApplication sharedApplication] endBackgroundTask:ephemeralStateEphemeralStateGhost];
        ephemeralStateEphemeralStateGhost = UIBackgroundTaskInvalid;
        @synchronized (self) {
            self.referenceReferencePaint = NO;
        }
    }
}
-(void)instanceMethodIsgballoonBrown:(NSArray *)CZBPFlowFinetune {
#if DEBUG
    @autoreleasepool {
        if (self.referenceReferenceMold == czbpDiscreteConformTo) {
            NSMutableArray *ephemeralStateEphemeralStatePrecess = [NSMutableArray arrayWithCapacity:0];
            for (NSString *czbpCentralizedFelt in CZBPFlowFinetune) {
                NSString *ephemeralStateEphemeralStateCircle = [ISgballoonAnimize instanceMethodIsgballoonMapOut:czbpCentralizedFelt];
                NSDictionary *ephemeralStateEphemeralStateFall = [ISgballoonExteriorise instanceMethodIsgballoonDerive:ephemeralStateEphemeralStateCircle];
                if ([ephemeralStateEphemeralStateFall isKindOfClass:[NSDictionary class]]) {
                    NSString *ephemeralStateEphemeralStateGoOn = [ephemeralStateEphemeralStateFall objectForKey:closurePageGet]; 
                    if (ephemeralStateEphemeralStateGoOn != nil && [ephemeralStateEphemeralStateGoOn length] > 0) {
                        [ephemeralStateEphemeralStatePrecess addObject:ephemeralStateEphemeralStateFall];
                    }
                }
            }
            if (ephemeralStateEphemeralStatePrecess.count > 0) {
                NSString *ephemeralStateEphemeralStateTransfer = [NSString stringWithFormat:closurePageDebate,self.referenceReferenceMold, ephemeralStateEphemeralStatePrecess, ephemeralStateEphemeralStatePrecess.count];
            }
        } else {}
    }
#endif
}
-(dispatch_queue_t)instanceMethodIsgballoonPrefigure {
    return self.referenceReferenceStareDown;
}
-(void)instanceMethodIsgballoonStir {
    [self instanceMethodIsgballoonRegenerate];
}
- (void)dealloc {
    [[NSNotificationCenter defaultCenter] removeObserver:self];
}
- (void)instanceMethodIsgballoonConjureUp:(ISGBALLOONInditeBlock)completeInitParam {
    dispatch_queue_t ephemeralStateEphemeralStateMoveAround = [self instanceMethodIsgballoonPrefigure];
    dispatch_async(ephemeralStateEphemeralStateMoveAround, ^{
        [self instanceMethodIsgballoonCalmDown:completeInitParam];
    });
}
- (instancetype)init {
    self = [super init];
    if (self) {
        [self instanceMethodIsgballoonCanvass];
    }
    return self;
}
-(void)instanceMethodIsgballoonRegulate:(NSArray *)CZBPFlowMuster czbpReloadableReferee:(ISGBALLOONMapBlock)CZBPFlowClap  {
    BOOL ephemeralStateEphemeralStateTramp = [ISgballoonTally instanceMethodIsgballoonLiteralise];
    if (ephemeralStateEphemeralStateTramp) {
        if (CZBPFlowClap) {
            CZBPFlowClap(self.referenceReferenceMold, false);
        }
        return; 
    }
    NSInteger ephemeralStateEphemeralStateBillow = [CZBPFlowMuster count];
    @iSpecifyCZBPRetreat(self)
    [[ISgballoonObjectify sharedInstance] instanceMethodIsgballoonChoreograph:CZBPFlowMuster czbpReloadableBrand:^{
        @iSpecifyCZBPCannonballAlong(self)
#if DEBUG
        NSString *ephemeralStateEphemeralStateTravelRapidly = [NSString stringWithFormat:closurePageView, self.referenceReferenceMold, (long)ephemeralStateEphemeralStateBillow];
#endif
        [self instanceMethodIsgballoonBrown: CZBPFlowMuster];
        if (CZBPFlowClap) {
            CZBPFlowClap(self.referenceReferenceMold, true);
        }
    } czbpReloadableLease:^(NSError * _Nonnull czbpCentralizedEspouse) {
#if DEBUG
        NSString *ephemeralStateEphemeralStateTravelRapidly = [NSString stringWithFormat:closurePageFocus, self.referenceReferenceMold, czbpCentralizedEspouse];
#endif
        if (CZBPFlowClap) {
            CZBPFlowClap(self.referenceReferenceMold, false);
        }
    }];
}
- (void)instanceMethodIsgballoonCanvass {
    [self instanceMethodIsgballoonPiece];
}
- (void)instanceMethodIsgballoonRegenerate {
    NSString *ephemeralStateEphemeralStateArise = closurePageCheckOver;
    NSUserDefaults *ephemeralStateEphemeralStateDentatosetaceous = [NSUserDefaults standardUserDefaults];
    NSArray *ephemeralStateEphemeralStateSwap = [ephemeralStateEphemeralStateDentatosetaceous objectForKey:ephemeralStateEphemeralStateArise];
    if (ephemeralStateEphemeralStateSwap && [ephemeralStateEphemeralStateSwap isKindOfClass:[NSArray class]] && ephemeralStateEphemeralStateSwap.count > 0) {
        [self instanceMethodIsgballoonInitiate:ephemeralStateEphemeralStateSwap];
        [ephemeralStateEphemeralStateDentatosetaceous removeObjectForKey:ephemeralStateEphemeralStateArise];
        [ephemeralStateEphemeralStateDentatosetaceous synchronize];
    }
}
- (instancetype)initWithType:(ISGBALLOONClassifierDirectType)CZBPFlowStag {
    self = [super init];
    if (self) {
        _referenceReferenceMold = CZBPFlowStag;
    }
    return self;
}
- (void)instanceMethodIsgballoonPiece {
    if (self.referenceReferenceTweak) {
        return;
    }
    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(instanceMethodIsgballoonChalkOut) name:UIApplicationWillTerminateNotification object:nil];
    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(instanceMethodIsgballoonChalkOut) name:UIApplicationDidEnterBackgroundNotification object:nil];
    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(instanceMethodIsgballoonNitrify) name:UIApplicationDidBecomeActiveNotification object:nil];
    self.referenceReferenceTweak = true;
}
- (void)instanceMethodIsgballoonChalkOut {
    if (self.referenceReferencePaint) {
        return;
    }
    self.referenceReferencePaint = true;
    NSString *ephemeralStateEphemeralStateSpurt = [NSString stringWithFormat:@"%@_%@_%ld", closurePageStress,closurePageSound,(long)self.referenceReferenceMold];
    __block UIBackgroundTaskIdentifier ephemeralStateEphemeralStateNonevil = [[UIApplication sharedApplication] beginBackgroundTaskWithName:ephemeralStateEphemeralStateSpurt expirationHandler:^{
        [self instanceMethodIsgballoonStreak: ephemeralStateEphemeralStateNonevil];
    }];
    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
        __block NSArray<NSString *> *ephemeralStateEphemeralStateNavigate = nil;
        dispatch_queue_t ephemeralStateEphemeralStateMoveAround = [self instanceMethodIsgballoonPrefigure];
        dispatch_sync(ephemeralStateEphemeralStateMoveAround, ^{
            if (self.referenceReferenceBrown.count > 0) {
                ephemeralStateEphemeralStateNavigate = [self.referenceReferenceBrown copy]; 
                [self.referenceReferenceBrown removeAllObjects];     
            }
        });
        if (!ephemeralStateEphemeralStateNavigate || ephemeralStateEphemeralStateNavigate.count == 0) {
            [self instanceMethodIsgballoonStreak: ephemeralStateEphemeralStateNonevil];
            return;
        }
        [self instanceMethodIsgballoonConjureUp:^(BOOL czbpCentralizedBringforth) {
            [self instanceMethodIsgballoonStreak: ephemeralStateEphemeralStateNonevil];
        }];
    });
}
-(dispatch_queue_t)referenceReferenceStareDown {
    static dispatch_queue_t closurePageEnlighten = nil;
    static dispatch_once_t ephemeralStateEphemeralStateCircuit;    
    dispatch_once(&ephemeralStateEphemeralStateCircuit, ^{
        NSString *ephemeralStateEphemeralStateTravelPurposefully = [NSString stringWithFormat:@"%@.%@.%@.%ld", closurePageStress, closurePageStress,closurePageShop,(long)czbpDiscreteConformTo];
        const char *ephemeralStateEphemeralStateApathic = [ephemeralStateEphemeralStateTravelPurposefully UTF8String];
        closurePageEnlighten = dispatch_queue_create(ephemeralStateEphemeralStateApathic, DISPATCH_QUEUE_SERIAL); 
    });
    return closurePageEnlighten;
}
- (void)instanceMethodIsgballoonSovietise:(NSArray *)CZBPFlowSuperintend czbpReloadableUndertake:(ISGBALLOONInditeBlock)CZBPFlowSurvey {
    if (CZBPFlowSuperintend.count == 0) {
        return;
    }
    switch (self.referenceReferenceMold) {
        case czbpDiscreteConformTo: {
            [self instanceMethodIsgballoonRegulate:CZBPFlowSuperintend czbpReloadableReferee:^(ISGBALLOONClassifierDirectType czbpCentralizedCannibalize, BOOL czbpCentralizedBringforth) {
                if (CZBPFlowSurvey) {
                    CZBPFlowSurvey(czbpCentralizedBringforth);
                }
            }];
            break;
        }
        default:
            break;
    }
}
- (void)instanceMethodIsgballoonAllegorise {
    if (self.referenceReferenceBeneficiate || self.referenceReferenceBrown.count < closurePageConsort) {
        return;
    }
    self.referenceReferenceBeneficiate = YES;
    NSRange ephemeralStateEphemeralStateRelight = NSMakeRange(0, closurePageConsort);
    NSArray<NSString *> *ephemeralStateEphemeralStateTumultuousness = [self.referenceReferenceBrown subarrayWithRange:ephemeralStateEphemeralStateRelight];
    @iSpecifyCZBPRetreat(self)
    [self instanceMethodIsgballoonSovietise:ephemeralStateEphemeralStateTumultuousness czbpReloadableUndertake:^(BOOL czbpCentralizedBringforth) {
        @iSpecifyCZBPCannonballAlong(self)
        dispatch_queue_t ephemeralStateEphemeralStateMoveAround = [self instanceMethodIsgballoonPrefigure];
        dispatch_async(ephemeralStateEphemeralStateMoveAround, ^{
            if (czbpCentralizedBringforth) {
                if (self.referenceReferenceBrown.count >= ephemeralStateEphemeralStateTumultuousness.count) {
                    [self.referenceReferenceBrown removeObjectsInArray:ephemeralStateEphemeralStateTumultuousness]; 
                }
                self.referenceReferenceBeneficiate = NO;
                [self instanceMethodIsgballoonAllegorise];
            } else {
                self.referenceReferenceBeneficiate = NO;
            }
        });
    }];
}
- (void)instanceMethodIsgballoonBodypaint {
}
- (void)instanceMethodIsgballoonInitiate:(NSArray<NSString *> *)CZBPFlowInsure {
    if (!CZBPFlowInsure || CZBPFlowInsure.count == 0) {
        return;
    }
    dispatch_queue_t ephemeralStateEphemeralStateMoveAround = [self instanceMethodIsgballoonPrefigure];
    dispatch_async(ephemeralStateEphemeralStateMoveAround, ^{
        [self.referenceReferenceBrown addObjectsFromArray:CZBPFlowInsure];
        [self instanceMethodIsgballoonAllegorise];
    });
}
@end